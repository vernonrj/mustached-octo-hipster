\section{Method}
The main strategy applied in the design of this project was divide and conquer; In order to keep the code as independent as possible the different types of instructions were decoupled. After doing a quick statistical analysis of the break down of instruction types conditionals, calls and returns are the most frequently encountered, in that order. Conditional branches comprised a significant majority of all branches encountered in any of the traces and had a very interesting pattern to them.
\begin{figure}
\includegraphics[width=8cm]{"./Conditional Branches DIST-INT-4-histogram"}
\caption{Graph showing the typical relative offset breakdown of conditional branches, y axis is in frequency}
\end{figure}
\subsection{Trace Analysis}
By analyzing the relative branching distances of branch instructions an interesting pattern emerged in Conditional Branches. A majority of them are backward branching and nearly all of them are contained within 1024 bytes. This information greatly influenced our design decisions outlined in the next major section. 
\begin{figure}
\includegraphics[width=8cm]{"./Calls Branches DIST-SERV-4-density"}
\includegraphics[width=8cm]{"./Calls Branches DIST-SERV-4-histogram"}
\caption{Graphs showing the complications in predicting functional calls efficiently}
\end{figure}
Functional calls were more staggered as far as PC relative. Across all of the traces however there were interesting density patterns for calls. Almost all of the branches are concentrated in two areas. Which directly corresponds to a typical virtual address space implemented on most operating systems. The density graph shows that 

\subsection{Memory Constraints}
8KB was the hard limit required for the project.